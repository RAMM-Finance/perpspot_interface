/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type { FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../common";

export type URateParamStruct = {
  pivotRate: PromiseOrValue<BigNumberish>;
  slope1: PromiseOrValue<BigNumberish>;
  intercept1: PromiseOrValue<BigNumberish>;
  slope2: PromiseOrValue<BigNumberish>;
  intercept2: PromiseOrValue<BigNumberish>;
};

export type URateParamStructOutput = [
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber
] & {
  pivotRate: BigNumber;
  slope1: BigNumber;
  intercept1: BigNumber;
  slope2: BigNumber;
  intercept2: BigNumber;
};

export type PoolParamStruct = {
  uParam: URateParamStruct;
  maxURate: PromiseOrValue<BigNumberish>;
  maxSearchRight: PromiseOrValue<BigNumberish>;
  maxSearchLeft: PromiseOrValue<BigNumberish>;
  poolId: PromiseOrValue<BigNumberish>;
  MIN_PREMIUM_DEPOSIT: PromiseOrValue<BigNumberish>;
};

export type PoolParamStructOutput = [
  URateParamStructOutput,
  BigNumber,
  BigNumber,
  BigNumber,
  number,
  BigNumber
] & {
  uParam: URateParamStructOutput;
  maxURate: BigNumber;
  maxSearchRight: BigNumber;
  maxSearchLeft: BigNumber;
  poolId: number;
  MIN_PREMIUM_DEPOSIT: BigNumber;
};

export type PoolKeyStruct = {
  token0: PromiseOrValue<string>;
  token1: PromiseOrValue<string>;
  fee: PromiseOrValue<BigNumberish>;
};

export type PoolKeyStructOutput = [string, string, number] & {
  token0: string;
  token1: string;
  fee: number;
};

export type LiquidityLoanStruct = {
  tick: PromiseOrValue<BigNumberish>;
  liquidity: PromiseOrValue<BigNumberish>;
  premium: PromiseOrValue<BigNumberish>;
  Urate: PromiseOrValue<BigNumberish>;
  feeGrowthInside0LastX128: PromiseOrValue<BigNumberish>;
  feeGrowthInside1LastX128: PromiseOrValue<BigNumberish>;
  lastGrowth: PromiseOrValue<BigNumberish>;
};

export type LiquidityLoanStructOutput = [
  number,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber
] & {
  tick: number;
  liquidity: BigNumber;
  premium: BigNumber;
  Urate: BigNumber;
  feeGrowthInside0LastX128: BigNumber;
  feeGrowthInside1LastX128: BigNumber;
  lastGrowth: BigNumber;
};

export type UniswapPositionStruct = {
  totalFeeGrowthInside0LastX128: PromiseOrValue<BigNumberish>;
  totalFeeGrowthInside1LastX128: PromiseOrValue<BigNumberish>;
  amount: PromiseOrValue<BigNumberish>;
  tokensOwed0: PromiseOrValue<BigNumberish>;
  tokensOwed1: PromiseOrValue<BigNumberish>;
};

export type UniswapPositionStructOutput = [
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber
] & {
  totalFeeGrowthInside0LastX128: BigNumber;
  totalFeeGrowthInside1LastX128: BigNumber;
  amount: BigNumber;
  tokensOwed0: BigNumber;
  tokensOwed1: BigNumber;
};

export type PremiumsCollectedStruct = {
  premium0: PromiseOrValue<BigNumberish>;
  premium1: PromiseOrValue<BigNumberish>;
};

export type PremiumsCollectedStructOutput = [BigNumber, BigNumber] & {
  premium0: BigNumber;
  premium1: BigNumber;
};

export type UtilizationGrowthStruct = {
  growth: PromiseOrValue<BigNumberish>;
  lastURate: PromiseOrValue<BigNumberish>;
  lastUpdateTime: PromiseOrValue<BigNumberish>;
};

export type UtilizationGrowthStructOutput = [
  BigNumber,
  BigNumber,
  BigNumber
] & { growth: BigNumber; lastURate: BigNumber; lastUpdateTime: BigNumber };

export interface PoolManagerInterface extends utils.Interface {
  functions: {
    "Interests(address,int24)": FunctionFragment;
    "LiquidityBin(bytes32,int24)": FunctionFragment;
    "LiquidityPositions(bytes32,bytes32)": FunctionFragment;
    "PoolParams(address)": FunctionFragment;
    "UtilizationGrowths(address,int24)": FunctionFragment;
    "addPool(address,address,address,uint24,int24,((uint256,uint256,uint256,uint256,uint256),uint256,uint256,uint256,uint16,uint256))": FunctionFragment;
    "binBitmaps(bytes32,int16)": FunctionFragment;
    "borrowFacility()": FunctionFragment;
    "borrowedLiquidities(bytes32,int24)": FunctionFragment;
    "collectFees((address,address,uint24),int24,int24)": FunctionFragment;
    "feeAmountTickSpacing(uint24)": FunctionFragment;
    "findAndWithdraw((address,address,uint24),uint256,uint256,bool,uint256)": FunctionFragment;
    "findNearestInitializedBin(bytes32,int24,int24,int24,bool,uint256)": FunctionFragment;
    "getGrowth(address,int24,(uint256,uint256,uint256,uint256,uint256))": FunctionFragment;
    "getInterestGrowthInside(address,int24,int24,int24)": FunctionFragment;
    "getLiquidityInBin((address,address,uint24),int24)": FunctionFragment;
    "getLiquidityPosition((address,address,uint24),int24,int24,address)": FunctionFragment;
    "getParams((address,address,uint24))": FunctionFragment;
    "getPool(address,address,uint24)": FunctionFragment;
    "getPoolList()": FunctionFragment;
    "getPremiumsCollected((address,address,uint24))": FunctionFragment;
    "getTokenList()": FunctionFragment;
    "getURates((address,address,uint24),(int24,uint128,uint256,uint256,uint256,uint256,uint256)[])": FunctionFragment;
    "isBorrowable((address,address,uint24),(int24,uint128,uint256,uint256,uint256,uint256,uint256)[])": FunctionFragment;
    "marginFacility()": FunctionFragment;
    "mintToRepay((address,address,uint24),(int24,uint128,uint256,uint256,uint256,uint256,uint256)[],address)": FunctionFragment;
    "multicall(bytes[])": FunctionFragment;
    "orderFacility()": FunctionFragment;
    "owner()": FunctionFragment;
    "payInterest((address,address,uint24),address,(int24,uint128,uint256,uint256,uint256,uint256,uint256)[],bool,uint256,uint256,uint256)": FunctionFragment;
    "provideDiscreteLiquidity((address,address,uint24),int24,int24,uint128,address,address)": FunctionFragment;
    "reclaimer()": FunctionFragment;
    "setFacilities(address,address,address,address)": FunctionFragment;
    "tickDiscretizations(bytes32)": FunctionFragment;
    "uniswapV3MintCallback(uint256,uint256,bytes)": FunctionFragment;
    "updateCollectedFees((address,address,uint24),int24,int24,int24)": FunctionFragment;
    "updatePoolParams(address,((uint256,uint256,uint256,uint256,uint256),uint256,uint256,uint256,uint16,uint256))": FunctionFragment;
    "updateUtilizationGrowth((address,address,uint24),int24)": FunctionFragment;
    "withdrawDiscreteLiquidity((address,address,uint24),int24,int24,uint128)": FunctionFragment;
    "withdrawToBorrow((address,address,uint24),(int24,uint128,uint256,uint256,uint256,uint256,uint256)[])": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "Interests"
      | "LiquidityBin"
      | "LiquidityPositions"
      | "PoolParams"
      | "UtilizationGrowths"
      | "addPool"
      | "binBitmaps"
      | "borrowFacility"
      | "borrowedLiquidities"
      | "collectFees"
      | "feeAmountTickSpacing"
      | "findAndWithdraw"
      | "findNearestInitializedBin"
      | "getGrowth"
      | "getInterestGrowthInside"
      | "getLiquidityInBin"
      | "getLiquidityPosition"
      | "getParams"
      | "getPool"
      | "getPoolList"
      | "getPremiumsCollected"
      | "getTokenList"
      | "getURates"
      | "isBorrowable"
      | "marginFacility"
      | "mintToRepay"
      | "multicall"
      | "orderFacility"
      | "owner"
      | "payInterest"
      | "provideDiscreteLiquidity"
      | "reclaimer"
      | "setFacilities"
      | "tickDiscretizations"
      | "uniswapV3MintCallback"
      | "updateCollectedFees"
      | "updatePoolParams"
      | "updateUtilizationGrowth"
      | "withdrawDiscreteLiquidity"
      | "withdrawToBorrow"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "Interests",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "LiquidityBin",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "LiquidityPositions",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "PoolParams",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "UtilizationGrowths",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "addPool",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PoolParamStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "binBitmaps",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "borrowFacility",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "borrowedLiquidities",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "collectFees",
    values: [
      PoolKeyStruct,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "feeAmountTickSpacing",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "findAndWithdraw",
    values: [
      PoolKeyStruct,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "findNearestInitializedBin",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getGrowth",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      URateParamStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getInterestGrowthInside",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getLiquidityInBin",
    values: [PoolKeyStruct, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getLiquidityPosition",
    values: [
      PoolKeyStruct,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getParams",
    values: [PoolKeyStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getPool",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getPoolList",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getPremiumsCollected",
    values: [PoolKeyStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenList",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getURates",
    values: [PoolKeyStruct, LiquidityLoanStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "isBorrowable",
    values: [PoolKeyStruct, LiquidityLoanStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "marginFacility",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "mintToRepay",
    values: [PoolKeyStruct, LiquidityLoanStruct[], PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "multicall",
    values: [PromiseOrValue<BytesLike>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "orderFacility",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "payInterest",
    values: [
      PoolKeyStruct,
      PromiseOrValue<string>,
      LiquidityLoanStruct[],
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "provideDiscreteLiquidity",
    values: [
      PoolKeyStruct,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(functionFragment: "reclaimer", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "setFacilities",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "tickDiscretizations",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "uniswapV3MintCallback",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "updateCollectedFees",
    values: [
      PoolKeyStruct,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "updatePoolParams",
    values: [PromiseOrValue<string>, PoolParamStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "updateUtilizationGrowth",
    values: [PoolKeyStruct, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawDiscreteLiquidity",
    values: [
      PoolKeyStruct,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawToBorrow",
    values: [PoolKeyStruct, LiquidityLoanStruct[]]
  ): string;

  decodeFunctionResult(functionFragment: "Interests", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "LiquidityBin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "LiquidityPositions",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "PoolParams", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "UtilizationGrowths",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "addPool", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "binBitmaps", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "borrowFacility",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "borrowedLiquidities",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "collectFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "feeAmountTickSpacing",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "findAndWithdraw",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "findNearestInitializedBin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getGrowth", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getInterestGrowthInside",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLiquidityInBin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLiquidityPosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getParams", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getPool", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getPoolList",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPremiumsCollected",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenList",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getURates", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isBorrowable",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "marginFacility",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "mintToRepay",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "multicall", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "orderFacility",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "payInterest",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "provideDiscreteLiquidity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "reclaimer", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setFacilities",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tickDiscretizations",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "uniswapV3MintCallback",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateCollectedFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updatePoolParams",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateUtilizationGrowth",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawDiscreteLiquidity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawToBorrow",
    data: BytesLike
  ): Result;

  events: {};
}

export interface PoolManager extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: PoolManagerInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    Interests(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { interest0: BigNumber; interest1: BigNumber }
    >;

    LiquidityBin(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    LiquidityPositions(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        totalFeeGrowthInside0LastX128: BigNumber;
        totalFeeGrowthInside1LastX128: BigNumber;
        amount: BigNumber;
        tokensOwed0: BigNumber;
        tokensOwed1: BigNumber;
      }
    >;

    PoolParams(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [
        URateParamStructOutput,
        BigNumber,
        BigNumber,
        BigNumber,
        number,
        BigNumber
      ] & {
        uParam: URateParamStructOutput;
        maxURate: BigNumber;
        maxSearchRight: BigNumber;
        maxSearchLeft: BigNumber;
        poolId: number;
        MIN_PREMIUM_DEPOSIT: BigNumber;
      }
    >;

    UtilizationGrowths(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        growth: BigNumber;
        lastURate: BigNumber;
        lastUpdateTime: BigNumber;
      }
    >;

    addPool(
      pool: PromiseOrValue<string>,
      tokenA: PromiseOrValue<string>,
      tokenB: PromiseOrValue<string>,
      fee: PromiseOrValue<BigNumberish>,
      tickDiscretization: PromiseOrValue<BigNumberish>,
      param: PoolParamStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    binBitmaps(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    borrowFacility(overrides?: CallOverrides): Promise<[string]>;

    borrowedLiquidities(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    collectFees(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    feeAmountTickSpacing(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[number]>;

    findAndWithdraw(
      key: PoolKeyStruct,
      margin: PromiseOrValue<BigNumberish>,
      borrowAmount: PromiseOrValue<BigNumberish>,
      borrowBelow: PromiseOrValue<boolean>,
      estimatedMinimumSlippage: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    findNearestInitializedBin(
      id: PromiseOrValue<BytesLike>,
      startingTick: PromiseOrValue<BigNumberish>,
      finishTick: PromiseOrValue<BigNumberish>,
      binSize: PromiseOrValue<BigNumberish>,
      lte: PromiseOrValue<boolean>,
      n: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[number, boolean] & { nextTick: number; success: boolean }>;

    getGrowth(
      pool: PromiseOrValue<string>,
      tick: PromiseOrValue<BigNumberish>,
      param: URateParamStruct,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getInterestGrowthInside(
      pool: PromiseOrValue<string>,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      tickDiscretization: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { interest0: BigNumber; interest1: BigNumber }
    >;

    getLiquidityInBin(
      key: PoolKeyStruct,
      tick: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getLiquidityPosition(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[UniswapPositionStructOutput]>;

    getParams(
      key: PoolKeyStruct,
      overrides?: CallOverrides
    ): Promise<
      [string, number, PoolParamStructOutput] & {
        pool: string;
        tickDiscretization: number;
        param: PoolParamStructOutput;
      }
    >;

    getPool(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getPoolList(overrides?: CallOverrides): Promise<[string[]]>;

    getPremiumsCollected(
      key: PoolKeyStruct,
      overrides?: CallOverrides
    ): Promise<[PremiumsCollectedStructOutput]>;

    getTokenList(overrides?: CallOverrides): Promise<[string[]]>;

    getURates(
      key: PoolKeyStruct,
      borrowInfo: LiquidityLoanStruct[],
      overrides?: CallOverrides
    ): Promise<[LiquidityLoanStructOutput[]]>;

    isBorrowable(
      key: PoolKeyStruct,
      borrowInfo: LiquidityLoanStruct[],
      overrides?: CallOverrides
    ): Promise<[boolean, LiquidityLoanStructOutput[]]>;

    marginFacility(overrides?: CallOverrides): Promise<[string]>;

    mintToRepay(
      key: PoolKeyStruct,
      repayInfo: LiquidityLoanStruct[],
      who: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    orderFacility(overrides?: CallOverrides): Promise<[string]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    payInterest(
      key: PoolKeyStruct,
      pool: PromiseOrValue<string>,
      borrowInfo: LiquidityLoanStruct[],
      positionIsToken0: PromiseOrValue<boolean>,
      feePortion: PromiseOrValue<BigNumberish>,
      premiumInBorrowedAsset: PromiseOrValue<BigNumberish>,
      premiumInPairAsset: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    provideDiscreteLiquidity(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      liquidity: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      payer: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    reclaimer(overrides?: CallOverrides): Promise<[string]>;

    setFacilities(
      mf: PromiseOrValue<string>,
      bf: PromiseOrValue<string>,
      of_: PromiseOrValue<string>,
      _uniswapFactory: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    tickDiscretizations(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[number]>;

    uniswapV3MintCallback(
      amount0Owed: PromiseOrValue<BigNumberish>,
      amount1Owed: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateCollectedFees(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      tickDiscretization: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updatePoolParams(
      pool: PromiseOrValue<string>,
      param: PoolParamStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateUtilizationGrowth(
      key: PoolKeyStruct,
      tick: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawDiscreteLiquidity(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      liquidity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawToBorrow(
      key: PoolKeyStruct,
      borrowInfo: LiquidityLoanStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  Interests(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber] & { interest0: BigNumber; interest1: BigNumber }
  >;

  LiquidityBin(
    arg0: PromiseOrValue<BytesLike>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  LiquidityPositions(
    arg0: PromiseOrValue<BytesLike>,
    arg1: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
      totalFeeGrowthInside0LastX128: BigNumber;
      totalFeeGrowthInside1LastX128: BigNumber;
      amount: BigNumber;
      tokensOwed0: BigNumber;
      tokensOwed1: BigNumber;
    }
  >;

  PoolParams(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [
      URateParamStructOutput,
      BigNumber,
      BigNumber,
      BigNumber,
      number,
      BigNumber
    ] & {
      uParam: URateParamStructOutput;
      maxURate: BigNumber;
      maxSearchRight: BigNumber;
      maxSearchLeft: BigNumber;
      poolId: number;
      MIN_PREMIUM_DEPOSIT: BigNumber;
    }
  >;

  UtilizationGrowths(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      growth: BigNumber;
      lastURate: BigNumber;
      lastUpdateTime: BigNumber;
    }
  >;

  addPool(
    pool: PromiseOrValue<string>,
    tokenA: PromiseOrValue<string>,
    tokenB: PromiseOrValue<string>,
    fee: PromiseOrValue<BigNumberish>,
    tickDiscretization: PromiseOrValue<BigNumberish>,
    param: PoolParamStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  binBitmaps(
    arg0: PromiseOrValue<BytesLike>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  borrowFacility(overrides?: CallOverrides): Promise<string>;

  borrowedLiquidities(
    arg0: PromiseOrValue<BytesLike>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  collectFees(
    key: PoolKeyStruct,
    tickLower: PromiseOrValue<BigNumberish>,
    tickUpper: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  feeAmountTickSpacing(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<number>;

  findAndWithdraw(
    key: PoolKeyStruct,
    margin: PromiseOrValue<BigNumberish>,
    borrowAmount: PromiseOrValue<BigNumberish>,
    borrowBelow: PromiseOrValue<boolean>,
    estimatedMinimumSlippage: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  findNearestInitializedBin(
    id: PromiseOrValue<BytesLike>,
    startingTick: PromiseOrValue<BigNumberish>,
    finishTick: PromiseOrValue<BigNumberish>,
    binSize: PromiseOrValue<BigNumberish>,
    lte: PromiseOrValue<boolean>,
    n: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<[number, boolean] & { nextTick: number; success: boolean }>;

  getGrowth(
    pool: PromiseOrValue<string>,
    tick: PromiseOrValue<BigNumberish>,
    param: URateParamStruct,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getInterestGrowthInside(
    pool: PromiseOrValue<string>,
    tickLower: PromiseOrValue<BigNumberish>,
    tickUpper: PromiseOrValue<BigNumberish>,
    tickDiscretization: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber] & { interest0: BigNumber; interest1: BigNumber }
  >;

  getLiquidityInBin(
    key: PoolKeyStruct,
    tick: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getLiquidityPosition(
    key: PoolKeyStruct,
    tickLower: PromiseOrValue<BigNumberish>,
    tickUpper: PromiseOrValue<BigNumberish>,
    owner: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<UniswapPositionStructOutput>;

  getParams(
    key: PoolKeyStruct,
    overrides?: CallOverrides
  ): Promise<
    [string, number, PoolParamStructOutput] & {
      pool: string;
      tickDiscretization: number;
      param: PoolParamStructOutput;
    }
  >;

  getPool(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    arg2: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  getPoolList(overrides?: CallOverrides): Promise<string[]>;

  getPremiumsCollected(
    key: PoolKeyStruct,
    overrides?: CallOverrides
  ): Promise<PremiumsCollectedStructOutput>;

  getTokenList(overrides?: CallOverrides): Promise<string[]>;

  getURates(
    key: PoolKeyStruct,
    borrowInfo: LiquidityLoanStruct[],
    overrides?: CallOverrides
  ): Promise<LiquidityLoanStructOutput[]>;

  isBorrowable(
    key: PoolKeyStruct,
    borrowInfo: LiquidityLoanStruct[],
    overrides?: CallOverrides
  ): Promise<[boolean, LiquidityLoanStructOutput[]]>;

  marginFacility(overrides?: CallOverrides): Promise<string>;

  mintToRepay(
    key: PoolKeyStruct,
    repayInfo: LiquidityLoanStruct[],
    who: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  multicall(
    data: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  orderFacility(overrides?: CallOverrides): Promise<string>;

  owner(overrides?: CallOverrides): Promise<string>;

  payInterest(
    key: PoolKeyStruct,
    pool: PromiseOrValue<string>,
    borrowInfo: LiquidityLoanStruct[],
    positionIsToken0: PromiseOrValue<boolean>,
    feePortion: PromiseOrValue<BigNumberish>,
    premiumInBorrowedAsset: PromiseOrValue<BigNumberish>,
    premiumInPairAsset: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  provideDiscreteLiquidity(
    key: PoolKeyStruct,
    tickLower: PromiseOrValue<BigNumberish>,
    tickUpper: PromiseOrValue<BigNumberish>,
    liquidity: PromiseOrValue<BigNumberish>,
    recipient: PromiseOrValue<string>,
    payer: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  reclaimer(overrides?: CallOverrides): Promise<string>;

  setFacilities(
    mf: PromiseOrValue<string>,
    bf: PromiseOrValue<string>,
    of_: PromiseOrValue<string>,
    _uniswapFactory: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  tickDiscretizations(
    arg0: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<number>;

  uniswapV3MintCallback(
    amount0Owed: PromiseOrValue<BigNumberish>,
    amount1Owed: PromiseOrValue<BigNumberish>,
    data: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateCollectedFees(
    key: PoolKeyStruct,
    tickLower: PromiseOrValue<BigNumberish>,
    tickUpper: PromiseOrValue<BigNumberish>,
    tickDiscretization: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updatePoolParams(
    pool: PromiseOrValue<string>,
    param: PoolParamStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateUtilizationGrowth(
    key: PoolKeyStruct,
    tick: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawDiscreteLiquidity(
    key: PoolKeyStruct,
    tickLower: PromiseOrValue<BigNumberish>,
    tickUpper: PromiseOrValue<BigNumberish>,
    liquidity: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawToBorrow(
    key: PoolKeyStruct,
    borrowInfo: LiquidityLoanStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    Interests(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { interest0: BigNumber; interest1: BigNumber }
    >;

    LiquidityBin(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    LiquidityPositions(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        totalFeeGrowthInside0LastX128: BigNumber;
        totalFeeGrowthInside1LastX128: BigNumber;
        amount: BigNumber;
        tokensOwed0: BigNumber;
        tokensOwed1: BigNumber;
      }
    >;

    PoolParams(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [
        URateParamStructOutput,
        BigNumber,
        BigNumber,
        BigNumber,
        number,
        BigNumber
      ] & {
        uParam: URateParamStructOutput;
        maxURate: BigNumber;
        maxSearchRight: BigNumber;
        maxSearchLeft: BigNumber;
        poolId: number;
        MIN_PREMIUM_DEPOSIT: BigNumber;
      }
    >;

    UtilizationGrowths(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        growth: BigNumber;
        lastURate: BigNumber;
        lastUpdateTime: BigNumber;
      }
    >;

    addPool(
      pool: PromiseOrValue<string>,
      tokenA: PromiseOrValue<string>,
      tokenB: PromiseOrValue<string>,
      fee: PromiseOrValue<BigNumberish>,
      tickDiscretization: PromiseOrValue<BigNumberish>,
      param: PoolParamStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    binBitmaps(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    borrowFacility(overrides?: CallOverrides): Promise<string>;

    borrowedLiquidities(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    collectFees(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        premiumOwed0: BigNumber;
        premiumOwed1: BigNumber;
      }
    >;

    feeAmountTickSpacing(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<number>;

    findAndWithdraw(
      key: PoolKeyStruct,
      margin: PromiseOrValue<BigNumberish>,
      borrowAmount: PromiseOrValue<BigNumberish>,
      borrowBelow: PromiseOrValue<boolean>,
      estimatedMinimumSlippage: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        LiquidityLoanStructOutput[]
      ] & {
        sqrtStartingPriceX96: BigNumber;
        totalAmount0: BigNumber;
        totalAmount1: BigNumber;
        averagePrice: BigNumber;
        borrowInfo: LiquidityLoanStructOutput[];
      }
    >;

    findNearestInitializedBin(
      id: PromiseOrValue<BytesLike>,
      startingTick: PromiseOrValue<BigNumberish>,
      finishTick: PromiseOrValue<BigNumberish>,
      binSize: PromiseOrValue<BigNumberish>,
      lte: PromiseOrValue<boolean>,
      n: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[number, boolean] & { nextTick: number; success: boolean }>;

    getGrowth(
      pool: PromiseOrValue<string>,
      tick: PromiseOrValue<BigNumberish>,
      param: URateParamStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getInterestGrowthInside(
      pool: PromiseOrValue<string>,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      tickDiscretization: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { interest0: BigNumber; interest1: BigNumber }
    >;

    getLiquidityInBin(
      key: PoolKeyStruct,
      tick: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getLiquidityPosition(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<UniswapPositionStructOutput>;

    getParams(
      key: PoolKeyStruct,
      overrides?: CallOverrides
    ): Promise<
      [string, number, PoolParamStructOutput] & {
        pool: string;
        tickDiscretization: number;
        param: PoolParamStructOutput;
      }
    >;

    getPool(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    getPoolList(overrides?: CallOverrides): Promise<string[]>;

    getPremiumsCollected(
      key: PoolKeyStruct,
      overrides?: CallOverrides
    ): Promise<PremiumsCollectedStructOutput>;

    getTokenList(overrides?: CallOverrides): Promise<string[]>;

    getURates(
      key: PoolKeyStruct,
      borrowInfo: LiquidityLoanStruct[],
      overrides?: CallOverrides
    ): Promise<LiquidityLoanStructOutput[]>;

    isBorrowable(
      key: PoolKeyStruct,
      borrowInfo: LiquidityLoanStruct[],
      overrides?: CallOverrides
    ): Promise<[boolean, LiquidityLoanStructOutput[]]>;

    marginFacility(overrides?: CallOverrides): Promise<string>;

    mintToRepay(
      key: PoolKeyStruct,
      repayInfo: LiquidityLoanStruct[],
      who: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        totalAmount0: BigNumber;
        totalAmount1: BigNumber;
      }
    >;

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<string[]>;

    orderFacility(overrides?: CallOverrides): Promise<string>;

    owner(overrides?: CallOverrides): Promise<string>;

    payInterest(
      key: PoolKeyStruct,
      pool: PromiseOrValue<string>,
      borrowInfo: LiquidityLoanStruct[],
      positionIsToken0: PromiseOrValue<boolean>,
      feePortion: PromiseOrValue<BigNumberish>,
      premiumInBorrowedAsset: PromiseOrValue<BigNumberish>,
      premiumInPairAsset: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    provideDiscreteLiquidity(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      liquidity: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      payer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        totalAmount0: BigNumber;
        totalAmount1: BigNumber;
      }
    >;

    reclaimer(overrides?: CallOverrides): Promise<string>;

    setFacilities(
      mf: PromiseOrValue<string>,
      bf: PromiseOrValue<string>,
      of_: PromiseOrValue<string>,
      _uniswapFactory: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    tickDiscretizations(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<number>;

    uniswapV3MintCallback(
      amount0Owed: PromiseOrValue<BigNumberish>,
      amount1Owed: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateCollectedFees(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      tickDiscretization: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    updatePoolParams(
      pool: PromiseOrValue<string>,
      param: PoolParamStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    updateUtilizationGrowth(
      key: PoolKeyStruct,
      tick: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<UtilizationGrowthStructOutput>;

    withdrawDiscreteLiquidity(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      liquidity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    withdrawToBorrow(
      key: PoolKeyStruct,
      borrowInfo: LiquidityLoanStruct[],
      overrides?: CallOverrides
    ): Promise<
      [LiquidityLoanStructOutput[], BigNumber, BigNumber] & {
        totalAmount0: BigNumber;
        totalAmount1: BigNumber;
      }
    >;
  };

  filters: {};

  estimateGas: {
    Interests(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    LiquidityBin(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    LiquidityPositions(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    PoolParams(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    UtilizationGrowths(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    addPool(
      pool: PromiseOrValue<string>,
      tokenA: PromiseOrValue<string>,
      tokenB: PromiseOrValue<string>,
      fee: PromiseOrValue<BigNumberish>,
      tickDiscretization: PromiseOrValue<BigNumberish>,
      param: PoolParamStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    binBitmaps(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    borrowFacility(overrides?: CallOverrides): Promise<BigNumber>;

    borrowedLiquidities(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    collectFees(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    feeAmountTickSpacing(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    findAndWithdraw(
      key: PoolKeyStruct,
      margin: PromiseOrValue<BigNumberish>,
      borrowAmount: PromiseOrValue<BigNumberish>,
      borrowBelow: PromiseOrValue<boolean>,
      estimatedMinimumSlippage: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    findNearestInitializedBin(
      id: PromiseOrValue<BytesLike>,
      startingTick: PromiseOrValue<BigNumberish>,
      finishTick: PromiseOrValue<BigNumberish>,
      binSize: PromiseOrValue<BigNumberish>,
      lte: PromiseOrValue<boolean>,
      n: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getGrowth(
      pool: PromiseOrValue<string>,
      tick: PromiseOrValue<BigNumberish>,
      param: URateParamStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getInterestGrowthInside(
      pool: PromiseOrValue<string>,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      tickDiscretization: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getLiquidityInBin(
      key: PoolKeyStruct,
      tick: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getLiquidityPosition(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getParams(
      key: PoolKeyStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPool(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPoolList(overrides?: CallOverrides): Promise<BigNumber>;

    getPremiumsCollected(
      key: PoolKeyStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTokenList(overrides?: CallOverrides): Promise<BigNumber>;

    getURates(
      key: PoolKeyStruct,
      borrowInfo: LiquidityLoanStruct[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isBorrowable(
      key: PoolKeyStruct,
      borrowInfo: LiquidityLoanStruct[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    marginFacility(overrides?: CallOverrides): Promise<BigNumber>;

    mintToRepay(
      key: PoolKeyStruct,
      repayInfo: LiquidityLoanStruct[],
      who: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    orderFacility(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    payInterest(
      key: PoolKeyStruct,
      pool: PromiseOrValue<string>,
      borrowInfo: LiquidityLoanStruct[],
      positionIsToken0: PromiseOrValue<boolean>,
      feePortion: PromiseOrValue<BigNumberish>,
      premiumInBorrowedAsset: PromiseOrValue<BigNumberish>,
      premiumInPairAsset: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    provideDiscreteLiquidity(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      liquidity: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      payer: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    reclaimer(overrides?: CallOverrides): Promise<BigNumber>;

    setFacilities(
      mf: PromiseOrValue<string>,
      bf: PromiseOrValue<string>,
      of_: PromiseOrValue<string>,
      _uniswapFactory: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    tickDiscretizations(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    uniswapV3MintCallback(
      amount0Owed: PromiseOrValue<BigNumberish>,
      amount1Owed: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateCollectedFees(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      tickDiscretization: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updatePoolParams(
      pool: PromiseOrValue<string>,
      param: PoolParamStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateUtilizationGrowth(
      key: PoolKeyStruct,
      tick: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawDiscreteLiquidity(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      liquidity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawToBorrow(
      key: PoolKeyStruct,
      borrowInfo: LiquidityLoanStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    Interests(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    LiquidityBin(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    LiquidityPositions(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    PoolParams(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    UtilizationGrowths(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    addPool(
      pool: PromiseOrValue<string>,
      tokenA: PromiseOrValue<string>,
      tokenB: PromiseOrValue<string>,
      fee: PromiseOrValue<BigNumberish>,
      tickDiscretization: PromiseOrValue<BigNumberish>,
      param: PoolParamStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    binBitmaps(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    borrowFacility(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    borrowedLiquidities(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    collectFees(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    feeAmountTickSpacing(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    findAndWithdraw(
      key: PoolKeyStruct,
      margin: PromiseOrValue<BigNumberish>,
      borrowAmount: PromiseOrValue<BigNumberish>,
      borrowBelow: PromiseOrValue<boolean>,
      estimatedMinimumSlippage: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    findNearestInitializedBin(
      id: PromiseOrValue<BytesLike>,
      startingTick: PromiseOrValue<BigNumberish>,
      finishTick: PromiseOrValue<BigNumberish>,
      binSize: PromiseOrValue<BigNumberish>,
      lte: PromiseOrValue<boolean>,
      n: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getGrowth(
      pool: PromiseOrValue<string>,
      tick: PromiseOrValue<BigNumberish>,
      param: URateParamStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getInterestGrowthInside(
      pool: PromiseOrValue<string>,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      tickDiscretization: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getLiquidityInBin(
      key: PoolKeyStruct,
      tick: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getLiquidityPosition(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getParams(
      key: PoolKeyStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPool(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPoolList(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getPremiumsCollected(
      key: PoolKeyStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTokenList(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getURates(
      key: PoolKeyStruct,
      borrowInfo: LiquidityLoanStruct[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isBorrowable(
      key: PoolKeyStruct,
      borrowInfo: LiquidityLoanStruct[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    marginFacility(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    mintToRepay(
      key: PoolKeyStruct,
      repayInfo: LiquidityLoanStruct[],
      who: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    orderFacility(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    payInterest(
      key: PoolKeyStruct,
      pool: PromiseOrValue<string>,
      borrowInfo: LiquidityLoanStruct[],
      positionIsToken0: PromiseOrValue<boolean>,
      feePortion: PromiseOrValue<BigNumberish>,
      premiumInBorrowedAsset: PromiseOrValue<BigNumberish>,
      premiumInPairAsset: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    provideDiscreteLiquidity(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      liquidity: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      payer: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    reclaimer(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setFacilities(
      mf: PromiseOrValue<string>,
      bf: PromiseOrValue<string>,
      of_: PromiseOrValue<string>,
      _uniswapFactory: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    tickDiscretizations(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    uniswapV3MintCallback(
      amount0Owed: PromiseOrValue<BigNumberish>,
      amount1Owed: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateCollectedFees(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      tickDiscretization: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updatePoolParams(
      pool: PromiseOrValue<string>,
      param: PoolParamStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateUtilizationGrowth(
      key: PoolKeyStruct,
      tick: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawDiscreteLiquidity(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      liquidity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawToBorrow(
      key: PoolKeyStruct,
      borrowInfo: LiquidityLoanStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}

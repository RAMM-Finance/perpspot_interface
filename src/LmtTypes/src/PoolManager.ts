/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../common";

export type URateParamStruct = {
  pivotRate: PromiseOrValue<BigNumberish>;
  slope1: PromiseOrValue<BigNumberish>;
  intercept1: PromiseOrValue<BigNumberish>;
  slope2: PromiseOrValue<BigNumberish>;
  intercept2: PromiseOrValue<BigNumberish>;
  twatDiffScale: PromiseOrValue<BigNumberish>;
};

export type URateParamStructOutput = [
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber
] & {
  pivotRate: BigNumber;
  slope1: BigNumber;
  intercept1: BigNumber;
  slope2: BigNumber;
  intercept2: BigNumber;
  twatDiffScale: BigNumber;
};

export type PoolParamStruct = {
  uParam: URateParamStruct;
  maxURate: PromiseOrValue<BigNumberish>;
  maxSearchRight: PromiseOrValue<BigNumberish>;
  maxSearchLeft: PromiseOrValue<BigNumberish>;
  poolId: PromiseOrValue<BigNumberish>;
  MIN_PREMIUM_DEPOSIT: PromiseOrValue<BigNumberish>;
  REPAY_THRESHOLD: PromiseOrValue<BigNumberish>;
};

export type PoolParamStructOutput = [
  URateParamStructOutput,
  BigNumber,
  BigNumber,
  BigNumber,
  number,
  BigNumber,
  BigNumber
] & {
  uParam: URateParamStructOutput;
  maxURate: BigNumber;
  maxSearchRight: BigNumber;
  maxSearchLeft: BigNumber;
  poolId: number;
  MIN_PREMIUM_DEPOSIT: BigNumber;
  REPAY_THRESHOLD: BigNumber;
};

export type PoolKeyStruct = {
  token0: PromiseOrValue<string>;
  token1: PromiseOrValue<string>;
  fee: PromiseOrValue<BigNumberish>;
};

export type PoolKeyStructOutput = [string, string, number] & {
  token0: string;
  token1: string;
  fee: number;
};

export type LiquidityLoanStruct = {
  tick: PromiseOrValue<BigNumberish>;
  liquidity: PromiseOrValue<BigNumberish>;
  premium: PromiseOrValue<BigNumberish>;
  feeGrowthInside0LastX128: PromiseOrValue<BigNumberish>;
  feeGrowthInside1LastX128: PromiseOrValue<BigNumberish>;
  lastGrowth: PromiseOrValue<BigNumberish>;
};

export type LiquidityLoanStructOutput = [
  number,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber
] & {
  tick: number;
  liquidity: BigNumber;
  premium: BigNumber;
  feeGrowthInside0LastX128: BigNumber;
  feeGrowthInside1LastX128: BigNumber;
  lastGrowth: BigNumber;
};

export type UniswapPositionStruct = {
  totalFeeGrowthInside0LastX128: PromiseOrValue<BigNumberish>;
  totalFeeGrowthInside1LastX128: PromiseOrValue<BigNumberish>;
  amount: PromiseOrValue<BigNumberish>;
  tokensOwed0: PromiseOrValue<BigNumberish>;
  tokensOwed1: PromiseOrValue<BigNumberish>;
};

export type UniswapPositionStructOutput = [
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber
] & {
  totalFeeGrowthInside0LastX128: BigNumber;
  totalFeeGrowthInside1LastX128: BigNumber;
  amount: BigNumber;
  tokensOwed0: BigNumber;
  tokensOwed1: BigNumber;
};

export interface PoolManagerInterface extends utils.Interface {
  functions: {
    "Interests(bytes32,int24)": FunctionFragment;
    "LiquidityBin(bytes32,int24)": FunctionFragment;
    "LiquidityPositions(bytes32,bytes32)": FunctionFragment;
    "PoolParams(address)": FunctionFragment;
    "UtilizationGrowths(address,int24)": FunctionFragment;
    "addPool(address,address,address,uint24,int24,((uint256,uint256,uint256,uint256,uint256,uint256),uint256,uint256,uint256,uint16,uint256,uint256))": FunctionFragment;
    "binBitmaps(bytes32,int16)": FunctionFragment;
    "borrowedLiquidities(bytes32,int24)": FunctionFragment;
    "collectFees((address,address,uint24),int24,int24)": FunctionFragment;
    "feeParams(bytes32)": FunctionFragment;
    "findAndWithdraw((address,address,uint24),uint256,bool,uint256)": FunctionFragment;
    "findTicks((address,address,uint24),uint256,bool,uint256,uint160)": FunctionFragment;
    "getGrowth(address,int24,(uint256,uint256,uint256,uint256,uint256,uint256))": FunctionFragment;
    "getHashedKey((address,address,uint24))": FunctionFragment;
    "getHashedPositionKey(int24,int24,address)": FunctionFragment;
    "getInterestGrowthInside(bytes32,int24,int24,int24)": FunctionFragment;
    "getLiquidityPosition((address,address,uint24),int24,int24,address)": FunctionFragment;
    "getParams((address,address,uint24))": FunctionFragment;
    "getPool(address,address,uint24)": FunctionFragment;
    "getPoolList()": FunctionFragment;
    "initialize()": FunctionFragment;
    "marginFacility()": FunctionFragment;
    "minLiquidities(bytes32)": FunctionFragment;
    "mintToRepay((address,address,uint24),(int24,uint128,uint256,uint256,uint256,uint256)[],address)": FunctionFragment;
    "multicall(bytes[])": FunctionFragment;
    "owner()": FunctionFragment;
    "payInterest((address,address,uint24),(int24,uint128,uint256,uint256,uint256,uint256)[],bool,uint256)": FunctionFragment;
    "poolTrusted(address)": FunctionFragment;
    "provideDiscreteLiquidity((address,address,uint24),int24,int24,uint128,address)": FunctionFragment;
    "setFacilities(address)": FunctionFragment;
    "setOwner(address)": FunctionFragment;
    "tickDiscretizations(bytes32)": FunctionFragment;
    "uniswapV3MintCallback(uint256,uint256,bytes)": FunctionFragment;
    "updateCollectedFees((address,address,uint24),int24,int24,int24)": FunctionFragment;
    "updateFeeParams((address,address,uint24),uint256,uint256,uint256,uint256,uint256)": FunctionFragment;
    "updatePoolParams(address,((uint256,uint256,uint256,uint256,uint256,uint256),uint256,uint256,uint256,uint16,uint256,uint256))": FunctionFragment;
    "withdrawDiscreteLiquidity((address,address,uint24),int24,int24,uint128)": FunctionFragment;
    "withdrawToBorrow((address,address,uint24),(int24,uint128,uint256,uint256,uint256,uint256)[])": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "Interests"
      | "LiquidityBin"
      | "LiquidityPositions"
      | "PoolParams"
      | "UtilizationGrowths"
      | "addPool"
      | "binBitmaps"
      | "borrowedLiquidities"
      | "collectFees"
      | "feeParams"
      | "findAndWithdraw"
      | "findTicks"
      | "getGrowth"
      | "getHashedKey"
      | "getHashedPositionKey"
      | "getInterestGrowthInside"
      | "getLiquidityPosition"
      | "getParams"
      | "getPool"
      | "getPoolList"
      | "initialize"
      | "marginFacility"
      | "minLiquidities"
      | "mintToRepay"
      | "multicall"
      | "owner"
      | "payInterest"
      | "poolTrusted"
      | "provideDiscreteLiquidity"
      | "setFacilities"
      | "setOwner"
      | "tickDiscretizations"
      | "uniswapV3MintCallback"
      | "updateCollectedFees"
      | "updateFeeParams"
      | "updatePoolParams"
      | "withdrawDiscreteLiquidity"
      | "withdrawToBorrow"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "Interests",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "LiquidityBin",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "LiquidityPositions",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "PoolParams",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "UtilizationGrowths",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "addPool",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PoolParamStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "binBitmaps",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "borrowedLiquidities",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "collectFees",
    values: [
      PoolKeyStruct,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "feeParams",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "findAndWithdraw",
    values: [
      PoolKeyStruct,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "findTicks",
    values: [
      PoolKeyStruct,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getGrowth",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      URateParamStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getHashedKey",
    values: [PoolKeyStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getHashedPositionKey",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getInterestGrowthInside",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getLiquidityPosition",
    values: [
      PoolKeyStruct,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getParams",
    values: [PoolKeyStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getPool",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getPoolList",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "marginFacility",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "minLiquidities",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "mintToRepay",
    values: [PoolKeyStruct, LiquidityLoanStruct[], PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "multicall",
    values: [PromiseOrValue<BytesLike>[]]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "payInterest",
    values: [
      PoolKeyStruct,
      LiquidityLoanStruct[],
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "poolTrusted",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "provideDiscreteLiquidity",
    values: [
      PoolKeyStruct,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setFacilities",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setOwner",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "tickDiscretizations",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "uniswapV3MintCallback",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "updateCollectedFees",
    values: [
      PoolKeyStruct,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "updateFeeParams",
    values: [
      PoolKeyStruct,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "updatePoolParams",
    values: [PromiseOrValue<string>, PoolParamStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawDiscreteLiquidity",
    values: [
      PoolKeyStruct,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawToBorrow",
    values: [PoolKeyStruct, LiquidityLoanStruct[]]
  ): string;

  decodeFunctionResult(functionFragment: "Interests", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "LiquidityBin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "LiquidityPositions",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "PoolParams", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "UtilizationGrowths",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "addPool", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "binBitmaps", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "borrowedLiquidities",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "collectFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "feeParams", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "findAndWithdraw",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "findTicks", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getGrowth", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getHashedKey",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getHashedPositionKey",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getInterestGrowthInside",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLiquidityPosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getParams", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getPool", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getPoolList",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "marginFacility",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "minLiquidities",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "mintToRepay",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "multicall", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "payInterest",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "poolTrusted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "provideDiscreteLiquidity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setFacilities",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setOwner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "tickDiscretizations",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "uniswapV3MintCallback",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateCollectedFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateFeeParams",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updatePoolParams",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawDiscreteLiquidity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawToBorrow",
    data: BytesLike
  ): Result;

  events: {
    "CollectedFees(address,address,int24,int24,uint256,uint256)": EventFragment;
    "Initialized(uint8)": EventFragment;
    "LiquidityProvided(address,address,uint128,int24,int24)": EventFragment;
    "LiquidityWithdrawn(address,address,uint128,int24,int24)": EventFragment;
    "PoolAdded(address,address,address,uint24,int24)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "CollectedFees"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LiquidityProvided"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LiquidityWithdrawn"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PoolAdded"): EventFragment;
}

export interface CollectedFeesEventObject {
  pool: string;
  recipient: string;
  tickLower: number;
  tickUpper: number;
  premium0: BigNumber;
  premium1: BigNumber;
}
export type CollectedFeesEvent = TypedEvent<
  [string, string, number, number, BigNumber, BigNumber],
  CollectedFeesEventObject
>;

export type CollectedFeesEventFilter = TypedEventFilter<CollectedFeesEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface LiquidityProvidedEventObject {
  pool: string;
  recipient: string;
  liquidity: BigNumber;
  tickLower: number;
  tickUpper: number;
}
export type LiquidityProvidedEvent = TypedEvent<
  [string, string, BigNumber, number, number],
  LiquidityProvidedEventObject
>;

export type LiquidityProvidedEventFilter =
  TypedEventFilter<LiquidityProvidedEvent>;

export interface LiquidityWithdrawnEventObject {
  pool: string;
  recipient: string;
  liquidity: BigNumber;
  tickLower: number;
  tickUpper: number;
}
export type LiquidityWithdrawnEvent = TypedEvent<
  [string, string, BigNumber, number, number],
  LiquidityWithdrawnEventObject
>;

export type LiquidityWithdrawnEventFilter =
  TypedEventFilter<LiquidityWithdrawnEvent>;

export interface PoolAddedEventObject {
  pool: string;
  token0: string;
  token1: string;
  fee: number;
  tickDiscretization: number;
}
export type PoolAddedEvent = TypedEvent<
  [string, string, string, number, number],
  PoolAddedEventObject
>;

export type PoolAddedEventFilter = TypedEventFilter<PoolAddedEvent>;

export interface PoolManager extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: PoolManagerInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    Interests(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { interest0: BigNumber; interest1: BigNumber }
    >;

    LiquidityBin(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    LiquidityPositions(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        totalFeeGrowthInside0LastX128: BigNumber;
        totalFeeGrowthInside1LastX128: BigNumber;
        amount: BigNumber;
        tokensOwed0: BigNumber;
        tokensOwed1: BigNumber;
      }
    >;

    PoolParams(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [
        URateParamStructOutput,
        BigNumber,
        BigNumber,
        BigNumber,
        number,
        BigNumber,
        BigNumber
      ] & {
        uParam: URateParamStructOutput;
        maxURate: BigNumber;
        maxSearchRight: BigNumber;
        maxSearchLeft: BigNumber;
        poolId: number;
        MIN_PREMIUM_DEPOSIT: BigNumber;
        REPAY_THRESHOLD: BigNumber;
      }
    >;

    UtilizationGrowths(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        growth: BigNumber;
        lastURate: BigNumber;
        lastUpdateTime: BigNumber;
      }
    >;

    addPool(
      pool: PromiseOrValue<string>,
      tokenA: PromiseOrValue<string>,
      tokenB: PromiseOrValue<string>,
      fee: PromiseOrValue<BigNumberish>,
      tickDiscretization: PromiseOrValue<BigNumberish>,
      param: PoolParamStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    binBitmaps(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    borrowedLiquidities(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    collectFees(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    feeParams(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        openFee: BigNumber;
        feeToPool: BigNumber;
        profitFee: BigNumber;
        profitFeeToPool: BigNumber;
        LPFee: BigNumber;
      }
    >;

    findAndWithdraw(
      key: PoolKeyStruct,
      borrowAmount: PromiseOrValue<BigNumberish>,
      borrowBelow: PromiseOrValue<boolean>,
      simulatedOutput: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    findTicks(
      key: PoolKeyStruct,
      borrowAmount: PromiseOrValue<BigNumberish>,
      borrowBelow: PromiseOrValue<boolean>,
      simulatedOutput: PromiseOrValue<BigNumberish>,
      finishPriceX96: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, LiquidityLoanStructOutput[]] & {
        found: BigNumber;
        borrowInfo: LiquidityLoanStructOutput[];
      }
    >;

    getGrowth(
      pool: PromiseOrValue<string>,
      tick: PromiseOrValue<BigNumberish>,
      param: URateParamStruct,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getHashedKey(
      key: PoolKeyStruct,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getHashedPositionKey(
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getInterestGrowthInside(
      hashedKey: PromiseOrValue<BytesLike>,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      tickDiscretization: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { interest0: BigNumber; interest1: BigNumber }
    >;

    getLiquidityPosition(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[UniswapPositionStructOutput]>;

    getParams(
      key: PoolKeyStruct,
      overrides?: CallOverrides
    ): Promise<
      [string, number, PoolParamStructOutput] & {
        pool: string;
        tickDiscretization: number;
        param: PoolParamStructOutput;
      }
    >;

    getPool(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getPoolList(overrides?: CallOverrides): Promise<[string[]]>;

    initialize(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    marginFacility(overrides?: CallOverrides): Promise<[string]>;

    minLiquidities(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    mintToRepay(
      key: PoolKeyStruct,
      repayInfo: LiquidityLoanStruct[],
      who: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    payInterest(
      key: PoolKeyStruct,
      borrowInfo: LiquidityLoanStruct[],
      positionIsToken0: PromiseOrValue<boolean>,
      feePortion: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    poolTrusted(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    provideDiscreteLiquidity(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      liquidity: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setFacilities(
      mf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setOwner(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    tickDiscretizations(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[number]>;

    uniswapV3MintCallback(
      amount0Owed: PromiseOrValue<BigNumberish>,
      amount1Owed: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateCollectedFees(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      tickDiscretization: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateFeeParams(
      key: PoolKeyStruct,
      openFee: PromiseOrValue<BigNumberish>,
      feeToPool: PromiseOrValue<BigNumberish>,
      profitFee: PromiseOrValue<BigNumberish>,
      profitFeeToPool: PromiseOrValue<BigNumberish>,
      LPFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updatePoolParams(
      pool: PromiseOrValue<string>,
      param: PoolParamStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawDiscreteLiquidity(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      liquidity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawToBorrow(
      key: PoolKeyStruct,
      borrowInfo: LiquidityLoanStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  Interests(
    arg0: PromiseOrValue<BytesLike>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber] & { interest0: BigNumber; interest1: BigNumber }
  >;

  LiquidityBin(
    arg0: PromiseOrValue<BytesLike>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  LiquidityPositions(
    arg0: PromiseOrValue<BytesLike>,
    arg1: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
      totalFeeGrowthInside0LastX128: BigNumber;
      totalFeeGrowthInside1LastX128: BigNumber;
      amount: BigNumber;
      tokensOwed0: BigNumber;
      tokensOwed1: BigNumber;
    }
  >;

  PoolParams(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [
      URateParamStructOutput,
      BigNumber,
      BigNumber,
      BigNumber,
      number,
      BigNumber,
      BigNumber
    ] & {
      uParam: URateParamStructOutput;
      maxURate: BigNumber;
      maxSearchRight: BigNumber;
      maxSearchLeft: BigNumber;
      poolId: number;
      MIN_PREMIUM_DEPOSIT: BigNumber;
      REPAY_THRESHOLD: BigNumber;
    }
  >;

  UtilizationGrowths(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      growth: BigNumber;
      lastURate: BigNumber;
      lastUpdateTime: BigNumber;
    }
  >;

  addPool(
    pool: PromiseOrValue<string>,
    tokenA: PromiseOrValue<string>,
    tokenB: PromiseOrValue<string>,
    fee: PromiseOrValue<BigNumberish>,
    tickDiscretization: PromiseOrValue<BigNumberish>,
    param: PoolParamStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  binBitmaps(
    arg0: PromiseOrValue<BytesLike>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  borrowedLiquidities(
    arg0: PromiseOrValue<BytesLike>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  collectFees(
    key: PoolKeyStruct,
    tickLower: PromiseOrValue<BigNumberish>,
    tickUpper: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  feeParams(
    arg0: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
      openFee: BigNumber;
      feeToPool: BigNumber;
      profitFee: BigNumber;
      profitFeeToPool: BigNumber;
      LPFee: BigNumber;
    }
  >;

  findAndWithdraw(
    key: PoolKeyStruct,
    borrowAmount: PromiseOrValue<BigNumberish>,
    borrowBelow: PromiseOrValue<boolean>,
    simulatedOutput: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  findTicks(
    key: PoolKeyStruct,
    borrowAmount: PromiseOrValue<BigNumberish>,
    borrowBelow: PromiseOrValue<boolean>,
    simulatedOutput: PromiseOrValue<BigNumberish>,
    finishPriceX96: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, LiquidityLoanStructOutput[]] & {
      found: BigNumber;
      borrowInfo: LiquidityLoanStructOutput[];
    }
  >;

  getGrowth(
    pool: PromiseOrValue<string>,
    tick: PromiseOrValue<BigNumberish>,
    param: URateParamStruct,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getHashedKey(key: PoolKeyStruct, overrides?: CallOverrides): Promise<string>;

  getHashedPositionKey(
    tickLower: PromiseOrValue<BigNumberish>,
    tickUpper: PromiseOrValue<BigNumberish>,
    owner: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string>;

  getInterestGrowthInside(
    hashedKey: PromiseOrValue<BytesLike>,
    tickLower: PromiseOrValue<BigNumberish>,
    tickUpper: PromiseOrValue<BigNumberish>,
    tickDiscretization: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber] & { interest0: BigNumber; interest1: BigNumber }
  >;

  getLiquidityPosition(
    key: PoolKeyStruct,
    tickLower: PromiseOrValue<BigNumberish>,
    tickUpper: PromiseOrValue<BigNumberish>,
    owner: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<UniswapPositionStructOutput>;

  getParams(
    key: PoolKeyStruct,
    overrides?: CallOverrides
  ): Promise<
    [string, number, PoolParamStructOutput] & {
      pool: string;
      tickDiscretization: number;
      param: PoolParamStructOutput;
    }
  >;

  getPool(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    arg2: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  getPoolList(overrides?: CallOverrides): Promise<string[]>;

  initialize(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  marginFacility(overrides?: CallOverrides): Promise<string>;

  minLiquidities(
    arg0: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  mintToRepay(
    key: PoolKeyStruct,
    repayInfo: LiquidityLoanStruct[],
    who: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  multicall(
    data: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  owner(overrides?: CallOverrides): Promise<string>;

  payInterest(
    key: PoolKeyStruct,
    borrowInfo: LiquidityLoanStruct[],
    positionIsToken0: PromiseOrValue<boolean>,
    feePortion: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  poolTrusted(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  provideDiscreteLiquidity(
    key: PoolKeyStruct,
    tickLower: PromiseOrValue<BigNumberish>,
    tickUpper: PromiseOrValue<BigNumberish>,
    liquidity: PromiseOrValue<BigNumberish>,
    recipient: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setFacilities(
    mf: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setOwner(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  tickDiscretizations(
    arg0: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<number>;

  uniswapV3MintCallback(
    amount0Owed: PromiseOrValue<BigNumberish>,
    amount1Owed: PromiseOrValue<BigNumberish>,
    data: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateCollectedFees(
    key: PoolKeyStruct,
    tickLower: PromiseOrValue<BigNumberish>,
    tickUpper: PromiseOrValue<BigNumberish>,
    tickDiscretization: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateFeeParams(
    key: PoolKeyStruct,
    openFee: PromiseOrValue<BigNumberish>,
    feeToPool: PromiseOrValue<BigNumberish>,
    profitFee: PromiseOrValue<BigNumberish>,
    profitFeeToPool: PromiseOrValue<BigNumberish>,
    LPFee: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updatePoolParams(
    pool: PromiseOrValue<string>,
    param: PoolParamStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawDiscreteLiquidity(
    key: PoolKeyStruct,
    tickLower: PromiseOrValue<BigNumberish>,
    tickUpper: PromiseOrValue<BigNumberish>,
    liquidity: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawToBorrow(
    key: PoolKeyStruct,
    borrowInfo: LiquidityLoanStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    Interests(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { interest0: BigNumber; interest1: BigNumber }
    >;

    LiquidityBin(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    LiquidityPositions(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        totalFeeGrowthInside0LastX128: BigNumber;
        totalFeeGrowthInside1LastX128: BigNumber;
        amount: BigNumber;
        tokensOwed0: BigNumber;
        tokensOwed1: BigNumber;
      }
    >;

    PoolParams(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [
        URateParamStructOutput,
        BigNumber,
        BigNumber,
        BigNumber,
        number,
        BigNumber,
        BigNumber
      ] & {
        uParam: URateParamStructOutput;
        maxURate: BigNumber;
        maxSearchRight: BigNumber;
        maxSearchLeft: BigNumber;
        poolId: number;
        MIN_PREMIUM_DEPOSIT: BigNumber;
        REPAY_THRESHOLD: BigNumber;
      }
    >;

    UtilizationGrowths(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        growth: BigNumber;
        lastURate: BigNumber;
        lastUpdateTime: BigNumber;
      }
    >;

    addPool(
      pool: PromiseOrValue<string>,
      tokenA: PromiseOrValue<string>,
      tokenB: PromiseOrValue<string>,
      fee: PromiseOrValue<BigNumberish>,
      tickDiscretization: PromiseOrValue<BigNumberish>,
      param: PoolParamStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    binBitmaps(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    borrowedLiquidities(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    collectFees(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        collectedFees0: BigNumber;
        collectedFees1: BigNumber;
      }
    >;

    feeParams(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        openFee: BigNumber;
        feeToPool: BigNumber;
        profitFee: BigNumber;
        profitFeeToPool: BigNumber;
        LPFee: BigNumber;
      }
    >;

    findAndWithdraw(
      key: PoolKeyStruct,
      borrowAmount: PromiseOrValue<BigNumberish>,
      borrowBelow: PromiseOrValue<boolean>,
      simulatedOutput: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, LiquidityLoanStructOutput[]] & {
        totalAmount0: BigNumber;
        totalAmount1: BigNumber;
        borrowInfo: LiquidityLoanStructOutput[];
      }
    >;

    findTicks(
      key: PoolKeyStruct,
      borrowAmount: PromiseOrValue<BigNumberish>,
      borrowBelow: PromiseOrValue<boolean>,
      simulatedOutput: PromiseOrValue<BigNumberish>,
      finishPriceX96: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, LiquidityLoanStructOutput[]] & {
        found: BigNumber;
        borrowInfo: LiquidityLoanStructOutput[];
      }
    >;

    getGrowth(
      pool: PromiseOrValue<string>,
      tick: PromiseOrValue<BigNumberish>,
      param: URateParamStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getHashedKey(
      key: PoolKeyStruct,
      overrides?: CallOverrides
    ): Promise<string>;

    getHashedPositionKey(
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string>;

    getInterestGrowthInside(
      hashedKey: PromiseOrValue<BytesLike>,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      tickDiscretization: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { interest0: BigNumber; interest1: BigNumber }
    >;

    getLiquidityPosition(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<UniswapPositionStructOutput>;

    getParams(
      key: PoolKeyStruct,
      overrides?: CallOverrides
    ): Promise<
      [string, number, PoolParamStructOutput] & {
        pool: string;
        tickDiscretization: number;
        param: PoolParamStructOutput;
      }
    >;

    getPool(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    getPoolList(overrides?: CallOverrides): Promise<string[]>;

    initialize(overrides?: CallOverrides): Promise<void>;

    marginFacility(overrides?: CallOverrides): Promise<string>;

    minLiquidities(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    mintToRepay(
      key: PoolKeyStruct,
      repayInfo: LiquidityLoanStruct[],
      who: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        totalAmount0: BigNumber;
        totalAmount1: BigNumber;
      }
    >;

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<string[]>;

    owner(overrides?: CallOverrides): Promise<string>;

    payInterest(
      key: PoolKeyStruct,
      borrowInfo: LiquidityLoanStruct[],
      positionIsToken0: PromiseOrValue<boolean>,
      feePortion: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    poolTrusted(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    provideDiscreteLiquidity(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      liquidity: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        totalAmount0: BigNumber;
        totalAmount1: BigNumber;
      }
    >;

    setFacilities(
      mf: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setOwner(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    tickDiscretizations(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<number>;

    uniswapV3MintCallback(
      amount0Owed: PromiseOrValue<BigNumberish>,
      amount1Owed: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateCollectedFees(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      tickDiscretization: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    updateFeeParams(
      key: PoolKeyStruct,
      openFee: PromiseOrValue<BigNumberish>,
      feeToPool: PromiseOrValue<BigNumberish>,
      profitFee: PromiseOrValue<BigNumberish>,
      profitFeeToPool: PromiseOrValue<BigNumberish>,
      LPFee: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    updatePoolParams(
      pool: PromiseOrValue<string>,
      param: PoolParamStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    withdrawDiscreteLiquidity(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      liquidity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    withdrawToBorrow(
      key: PoolKeyStruct,
      borrowInfo: LiquidityLoanStruct[],
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        totalAmount0: BigNumber;
        totalAmount1: BigNumber;
      }
    >;
  };

  filters: {
    "CollectedFees(address,address,int24,int24,uint256,uint256)"(
      pool?: PromiseOrValue<string> | null,
      recipient?: PromiseOrValue<string> | null,
      tickLower?: null,
      tickUpper?: null,
      premium0?: null,
      premium1?: null
    ): CollectedFeesEventFilter;
    CollectedFees(
      pool?: PromiseOrValue<string> | null,
      recipient?: PromiseOrValue<string> | null,
      tickLower?: null,
      tickUpper?: null,
      premium0?: null,
      premium1?: null
    ): CollectedFeesEventFilter;

    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "LiquidityProvided(address,address,uint128,int24,int24)"(
      pool?: PromiseOrValue<string> | null,
      recipient?: PromiseOrValue<string> | null,
      liquidity?: null,
      tickLower?: null,
      tickUpper?: null
    ): LiquidityProvidedEventFilter;
    LiquidityProvided(
      pool?: PromiseOrValue<string> | null,
      recipient?: PromiseOrValue<string> | null,
      liquidity?: null,
      tickLower?: null,
      tickUpper?: null
    ): LiquidityProvidedEventFilter;

    "LiquidityWithdrawn(address,address,uint128,int24,int24)"(
      pool?: PromiseOrValue<string> | null,
      recipient?: PromiseOrValue<string> | null,
      liquidity?: null,
      tickLower?: null,
      tickUpper?: null
    ): LiquidityWithdrawnEventFilter;
    LiquidityWithdrawn(
      pool?: PromiseOrValue<string> | null,
      recipient?: PromiseOrValue<string> | null,
      liquidity?: null,
      tickLower?: null,
      tickUpper?: null
    ): LiquidityWithdrawnEventFilter;

    "PoolAdded(address,address,address,uint24,int24)"(
      pool?: PromiseOrValue<string> | null,
      token0?: PromiseOrValue<string> | null,
      token1?: PromiseOrValue<string> | null,
      fee?: null,
      tickDiscretization?: null
    ): PoolAddedEventFilter;
    PoolAdded(
      pool?: PromiseOrValue<string> | null,
      token0?: PromiseOrValue<string> | null,
      token1?: PromiseOrValue<string> | null,
      fee?: null,
      tickDiscretization?: null
    ): PoolAddedEventFilter;
  };

  estimateGas: {
    Interests(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    LiquidityBin(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    LiquidityPositions(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    PoolParams(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    UtilizationGrowths(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    addPool(
      pool: PromiseOrValue<string>,
      tokenA: PromiseOrValue<string>,
      tokenB: PromiseOrValue<string>,
      fee: PromiseOrValue<BigNumberish>,
      tickDiscretization: PromiseOrValue<BigNumberish>,
      param: PoolParamStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    binBitmaps(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    borrowedLiquidities(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    collectFees(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    feeParams(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    findAndWithdraw(
      key: PoolKeyStruct,
      borrowAmount: PromiseOrValue<BigNumberish>,
      borrowBelow: PromiseOrValue<boolean>,
      simulatedOutput: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    findTicks(
      key: PoolKeyStruct,
      borrowAmount: PromiseOrValue<BigNumberish>,
      borrowBelow: PromiseOrValue<boolean>,
      simulatedOutput: PromiseOrValue<BigNumberish>,
      finishPriceX96: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getGrowth(
      pool: PromiseOrValue<string>,
      tick: PromiseOrValue<BigNumberish>,
      param: URateParamStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getHashedKey(
      key: PoolKeyStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getHashedPositionKey(
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getInterestGrowthInside(
      hashedKey: PromiseOrValue<BytesLike>,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      tickDiscretization: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getLiquidityPosition(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getParams(
      key: PoolKeyStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPool(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPoolList(overrides?: CallOverrides): Promise<BigNumber>;

    initialize(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    marginFacility(overrides?: CallOverrides): Promise<BigNumber>;

    minLiquidities(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    mintToRepay(
      key: PoolKeyStruct,
      repayInfo: LiquidityLoanStruct[],
      who: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    payInterest(
      key: PoolKeyStruct,
      borrowInfo: LiquidityLoanStruct[],
      positionIsToken0: PromiseOrValue<boolean>,
      feePortion: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    poolTrusted(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    provideDiscreteLiquidity(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      liquidity: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setFacilities(
      mf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setOwner(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    tickDiscretizations(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    uniswapV3MintCallback(
      amount0Owed: PromiseOrValue<BigNumberish>,
      amount1Owed: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateCollectedFees(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      tickDiscretization: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateFeeParams(
      key: PoolKeyStruct,
      openFee: PromiseOrValue<BigNumberish>,
      feeToPool: PromiseOrValue<BigNumberish>,
      profitFee: PromiseOrValue<BigNumberish>,
      profitFeeToPool: PromiseOrValue<BigNumberish>,
      LPFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updatePoolParams(
      pool: PromiseOrValue<string>,
      param: PoolParamStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawDiscreteLiquidity(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      liquidity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawToBorrow(
      key: PoolKeyStruct,
      borrowInfo: LiquidityLoanStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    Interests(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    LiquidityBin(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    LiquidityPositions(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    PoolParams(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    UtilizationGrowths(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    addPool(
      pool: PromiseOrValue<string>,
      tokenA: PromiseOrValue<string>,
      tokenB: PromiseOrValue<string>,
      fee: PromiseOrValue<BigNumberish>,
      tickDiscretization: PromiseOrValue<BigNumberish>,
      param: PoolParamStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    binBitmaps(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    borrowedLiquidities(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    collectFees(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    feeParams(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    findAndWithdraw(
      key: PoolKeyStruct,
      borrowAmount: PromiseOrValue<BigNumberish>,
      borrowBelow: PromiseOrValue<boolean>,
      simulatedOutput: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    findTicks(
      key: PoolKeyStruct,
      borrowAmount: PromiseOrValue<BigNumberish>,
      borrowBelow: PromiseOrValue<boolean>,
      simulatedOutput: PromiseOrValue<BigNumberish>,
      finishPriceX96: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getGrowth(
      pool: PromiseOrValue<string>,
      tick: PromiseOrValue<BigNumberish>,
      param: URateParamStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getHashedKey(
      key: PoolKeyStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getHashedPositionKey(
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getInterestGrowthInside(
      hashedKey: PromiseOrValue<BytesLike>,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      tickDiscretization: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getLiquidityPosition(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getParams(
      key: PoolKeyStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPool(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPoolList(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    initialize(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    marginFacility(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    minLiquidities(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    mintToRepay(
      key: PoolKeyStruct,
      repayInfo: LiquidityLoanStruct[],
      who: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    payInterest(
      key: PoolKeyStruct,
      borrowInfo: LiquidityLoanStruct[],
      positionIsToken0: PromiseOrValue<boolean>,
      feePortion: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    poolTrusted(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    provideDiscreteLiquidity(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      liquidity: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setFacilities(
      mf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setOwner(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    tickDiscretizations(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    uniswapV3MintCallback(
      amount0Owed: PromiseOrValue<BigNumberish>,
      amount1Owed: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateCollectedFees(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      tickDiscretization: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateFeeParams(
      key: PoolKeyStruct,
      openFee: PromiseOrValue<BigNumberish>,
      feeToPool: PromiseOrValue<BigNumberish>,
      profitFee: PromiseOrValue<BigNumberish>,
      profitFeeToPool: PromiseOrValue<BigNumberish>,
      LPFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updatePoolParams(
      pool: PromiseOrValue<string>,
      param: PoolParamStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawDiscreteLiquidity(
      key: PoolKeyStruct,
      tickLower: PromiseOrValue<BigNumberish>,
      tickUpper: PromiseOrValue<BigNumberish>,
      liquidity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawToBorrow(
      key: PoolKeyStruct,
      borrowInfo: LiquidityLoanStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
